<html>

<head>
<title>Procedural Terrain Generator</title>
<meta http-equiv="content-type" content="text/html; charset=ISO-8859-1">

<script type="text/javascript" src="gl-Matrix.js"></script>
<script type="text/javascript" src="webgl-utils.js"></script>

<!-- Hint: Please note that I added all uniforms, attributes and varying parameters to each of vertex and fragment
   shaders, but you need to delete the unneeded ones from each shader.
   
   Start by implementation of your shaders, after completing shaders, work on the CPU part.
-->

<script id="terrain-fs" type="x-shader/x-fragment">
    precision mediump float;
    
    varying vec3 vColor;
    
    void main(void) {
    	gl_FragColor = vec4(vColor, 1.0);
    }
    
</script>

<script id="terrain-vs" type="x-shader/x-vertex">
    
    attribute vec3 aVertexPosition;
    
    uniform mat4 uMVMatrix;
    uniform mat4 uPMatrix;
    uniform vec3 uAmbientColor;
    
    varying vec3 vColor;
    
    void main(void) {
    
    	gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);
		vColor = uAmbientColor;
    }
    
</script>


<script type="text/javascript">
    
    var gl;
    
    function initGL(canvas) {
        try {
            gl = canvas.getContext("experimental-webgl");
            gl.viewportWidth = canvas.width;
            gl.viewportHeight = canvas.height;
        } catch (e) {
        }
        if (!gl) {
            alert("Could not initialise WebGL, sorry :-(");
        }
    }
    
    function getShader(gl, id) {
    
        var shaderScript = document.getElementById(id);
        if (!shaderScript) {
            return null;
        }
        var str = "";
        var k = shaderScript.firstChild;
        while (k) {
            if (k.nodeType == 3) {
                str += k.textContent;
            }
            k = k.nextSibling;
        }
        
        var shader;
        if (shaderScript.type == "x-shader/x-fragment") {
            shader = gl.createShader(gl.FRAGMENT_SHADER);
        } else if (shaderScript.type == "x-shader/x-vertex") {
            shader = gl.createShader(gl.VERTEX_SHADER);
        } else {
            return null;
        }
        
        gl.shaderSource(shader, str);
        gl.compileShader(shader);
        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
            alert(gl.getShaderInfoLog(shader));
            return null;
        }
        return shader;
    }
    
    var shaderProgram;
    
    function initShaders() {
    
        var vertexShader = getShader(gl, "terrain-vs");
        var fragmentShader = getShader(gl, "terrain-fs");
        
		shaderProgram = gl.createProgram();
		gl.attachShader(shaderProgram, vertexShader);
		gl.attachShader(shaderProgram, fragmentShader);
		gl.linkProgram(shaderProgram);
		if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
			alert("Could not initialise shaders");
		}
		
		shaderProgram.vertexPositionAttribute = gl.getAttribLocation(shaderProgram, "aVertexPosition");	
		shaderProgram.pMatrixUniform = gl.getUniformLocation(shaderProgram, "uPMatrix");
		shaderProgram.mvMatrixUniform = gl.getUniformLocation(shaderProgram, "uMVMatrix");
		shaderProgram.nMatrixUniform = gl.getUniformLocation(shaderProgram, "nMatrixUniform");
		shaderProgram.ambientColorUniform = gl.getUniformLocation(shaderProgram, "uAmbientColor");
        
               
    }
    
    var mvMatrix = mat4.create();
    var mvMatrixStack = [];
    var pMatrix = mat4.create();
    function mvPushMatrix() {
        var copy = mat4.create();
        mat4.set(mvMatrix, copy);
        mvMatrixStack.push(copy);
    }
    
    function mvPopMatrix() {
        if (mvMatrixStack.length == 0) {
            throw "Invalid popMatrix!";
        }
        mvMatrix = mvMatrixStack.pop();
    }
    
    function setMatrixUniforms() {
        gl.useProgram(shaderProgram);
	    gl.uniformMatrix4fv(shaderProgram.pMatrixUniform, false, pMatrix);
    	gl.uniformMatrix4fv(shaderProgram.mvMatrixUniform, false, mvMatrix);
    	var normalMatrix = mat3.create();
   	 	mat3.normalFromMat4(normalMatrix, mvMatrix);
     	gl.uniformMatrix3fv(shaderProgram.nMatrixUniform, false, normalMatrix);
    }
    
    function degToRad(degrees) {
        return degrees * Math.PI / 180;
    }
    
	var planeVertexPositionBuffer;
    var planeVertexNormalBuffer;
    var planeVertexIndexBuffer;
	
	function createPlane() {
	
		var vertices = [-1, -1, 0, 1, -1, 0, 1, 1, 0, -1, -1, 0];
		var normals = [0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0];
		var indices = [1,2,3,4];
	
		//vertex positions
		planeVertexPositionBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, planeVertexPositionBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
		planeVertexPositionBuffer.itemSize = 3;
        planeVertexPositionBuffer.numItems = vertices.length/planeVertexPositionBuffer.itemSize;
		
		//normals
		planeVertexNormalBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, planeVertexNormalBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(normals), gl.STATIC_DRAW);
		planeVertexNormalBuffer.itemSize = 3;
        planeVertexNormalBuffer.numItems = normals.length/planeVertexNormalBuffer.itemSize;
		
		//indices
		teapotVertexIndexBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, teapotVertexIndexBuffer);
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indices), gl.STATIC_DRAW);
		teapotVertexIndexBuffer.itemSize = 1;
        teapotVertexIndexBuffer.numItems = indices,length/teapotVertexIndexBuffer.itemSize;
	}
	
    function drawScene() {
        
		//create teaport vertexpositionbuffer
		
		gl.viewport(0, 0, gl.viewportWidth, gl.viewportHeight);
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
        
		//create projection matrix
        mat4.perspective(pMatrix, 45, gl.viewportWidth / gl.viewportHeight, 0.1, 100.0);
    
    	// First Teapot
    	gl.useProgram(shaderProgram);
		
		//create MV matrix
        mat4.identity(mvMatrix);
		mat4.scale(mvMatrix, mvMatrix, [0.35, 0.35, 0.35]);
        mat4.rotate(mvMatrix, mvMatrix, degToRad(23.4), [1, 0, -1]);
        mat4.translate(mvMatrix, mvMatrix, [-5, 5, -20]);
		
        gl.enableVertexAttribArray(shaderProgram.vertexPositionAttribute);
        gl.bindBuffer(gl.ARRAY_BUFFER, planeVertexPositionBuffer);
        gl.vertexAttribPointer(shaderProgram.vertexPositionAttribute, planeVertexPositionBuffer.itemSize, gl.FLOAT, false, 0, 0);
		
		//set uniforms
		setMatrixUniforms();
		gl.uniform3f(shaderProgram.ambientColorUniform, 1.0, 0.8, 0.0);
		
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, teapotVertexIndexBuffer);
        gl.drawElements(gl.TRIANGLES, teapotVertexIndexBuffer.numItems, gl.UNSIGNED_SHORT, 0);
        
    }
    
    function tick() {
        requestAnimFrame(tick);
        drawScene();
    }
    
    function webGLStart() {
        var canvas = document.getElementById("canvas");
        initGL(canvas);
        initShaders();
        gl.clearColor(0.0, 0.3, 0.7, 1.0);
        gl.enable(gl.DEPTH_TEST);
        tick();
    }
    
</script>

</head>


<body onload="webGLStart();">
    
    <canvas id="canvas" style="border: none;" width="500" height="500"></canvas>
</body>

</html>