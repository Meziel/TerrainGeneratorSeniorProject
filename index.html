<html>
	<head>
		<title>Procedural Terrain Generator</title>
		<meta http-equiv="content-type" content="text/html; charset=ISO-8859-1">

		<style>
			body {
				padding: 0;
				margin: 0;
			}
		</style>
		
		<script type="text/javascript" src="gl-Matrix.js"></script>
		<script type="text/javascript" src="webgl-utils.js"></script>
		<script type="text/javascript" src="terrain.js"></script>

		<script id="terrain-fs" type="x-shader/x-fragment">
		
			precision mediump float;

			uniform vec3 uPointLightingLocation;
			
			uniform vec3 uAmbientColor;
			uniform vec3 uMaterialDiffuseColor;
			uniform vec3 uMaterialSpecularColor;
	
			uniform float uMaterialShininess;
			
			varying vec3 vNormal;
			varying vec4 vPosition;
			varying float height;
			
			void main(void) {
				
				vec3 N = vNormal;
				vec3 L = normalize(uPointLightingLocation - vec3(vPosition));
				vec3 R = normalize(-reflect(L, N));
				vec3 V = normalize(-vec3(vPosition));
				
				//calculate diffuse
				float diffuseFactor = max(dot(N, L), 0.0); 
				vec3 diffuseColor = clamp(diffuseFactor * uMaterialDiffuseColor, 0.0, 1.0);
				
				//calculate specular
				float specularFactor = max(dot(R, V), 0.0);
				vec3 specularColor = clamp(pow(specularFactor, uMaterialShininess) * uMaterialSpecularColor, 0.0, 1.0);
				
				gl_FragColor = vec4((height * vec3(0.7, 0.7, 0.7), 1.0) + vec4(0.05, 0.05, 0.05, 0.05)) * vec4(uAmbientColor + diffuseColor + specularColor, 1.0);
			}
			
		</script>

		<script id="terrain-vs" type="x-shader/x-vertex">
		
			attribute vec3 aVertexPosition;
			attribute vec3 aVertexNormal;
			attribute float aRandom;
			
			uniform mat4 uMVMatrix;
			uniform mat4 uVMatrix;
			uniform mat4 uPMatrix;
			uniform mat3 uNMatrix;
			uniform int uSeed;
			
			varying vec3 vNormal;
			varying vec4 vPosition;
			varying float height;
			
			float random(float value, int seed) {
				float random = sin(value+float(seed)) * 1000.0;
				return 360.0*(random - floor(random));
			}
			
			float noise2D(float x, float y, float frequency, int seed) {
			
				x = abs(x);
				y = abs(y);
			
				float minX = floor(x/frequency) * frequency;
				float minY = floor(y/frequency) * frequency;
				float maxX = minX + frequency;
				float maxY = minY + frequency;
				
				vec2 gradient1 = normalize( vec2(cos(random(minX + 1000.0*maxY, seed)), sin(random(minX + 1000.0*maxY, seed))) );
				vec2 gradient2 = normalize( vec2(cos(random(maxX + 1000.0*maxY, seed)), sin(random(maxX + 1000.0*maxY, seed))) );
				vec2 gradient3 = normalize( vec2(cos(random(maxX + 1000.0*minY, seed)), sin(random(maxX + 1000.0*minY, seed))) );
				vec2 gradient4 = normalize( vec2(cos(random(minX + 1000.0*minY, seed)), sin(random(minX + 1000.0*minY, seed))) );
				
				vec2 distance1 = normalize(vec2(x, y) - vec2(minX, maxY));
				vec2 distance2 = normalize(vec2(x, y) - vec2(maxX, maxY));
				vec2 distance3 = normalize(vec2(x, y) - vec2(maxX, minY));
				vec2 distance4 = normalize(vec2(x, y) - vec2(minX, minY));
				
				float intensity1 = dot(gradient1, distance1);
				float intensity2 = dot(gradient2, distance2);
				float intensity3 = dot(gradient3, distance3);
				float intensity4 = dot(gradient4, distance4);
				
				float interp1 = mix(intensity1, intensity2, (x-minX) / (maxX-minX));
				float interp2 = mix(intensity3, intensity4, (x-minX) / (maxX-minX));
				float interp3 = mix(interp1, interp2, (y-minY) / (maxY-minY));
				
				return interp3;
			}
			
			void main(void) {
			
				vPosition = uMVMatrix * vec4(aVertexPosition, 1.0);
				
				height = noise2D(vPosition.x, vPosition.z, 50.0, uSeed);
				
				vPosition = vPosition + vec4(0.0, height*10.0, 0.0, 1.0);
				
				vNormal = normalize(uNMatrix * aVertexNormal);
				
				gl_Position = uPMatrix * uVMatrix * vPosition;
			}
			
		</script>
		
	</head>

	<body onload="start();">
		<canvas id="canvas"></canvas>
	</body>
</html>